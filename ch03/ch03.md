# 第三章 模块化

首先，我们想要理清一些在围绕模块化的架构讨论中使用并且过度使用的常见术语，并提供一些定义以便在本书中使用。

------

*95%的词[关于软件架构]都在颂扬“模块化”的好处上，而很少聊一些关于如何实现它。*

——格伦福德·j·迈尔斯(1978)

------

不同的平台提供了不同的代码重用机制，但都支持以某种方式将相关代码分组到*模块*中。虽然模块在软件架构中是一个通用的概念，但人们已经证明它是比较难以给出定义的。随便在网上搜索一下，就会得到几十种定义，没有一致性（也有一些矛盾）。正如你从在尔斯的话中所看到的，这不是一个新问题。然而，由于没有公认的定义存在，为了保持整本书的一致性，我们必须加入争论并提供我们自己的定义。

对于架构师来说，理解模块化及其所选择的开发平台中的许多方面是至关重要的。我们用来分析架构的许多工具（如指标、适应度函数和可视化）都依赖于这些模块化概念。模块化是一种组织原则。如果架构师在设计系统时不注意各个部分是如何连接在一起的，那么他们最终会创建出一个存在无数困难的系统。用一个物理类比，软件系统模拟趋于熵（或无序）的复杂系统。为了保持秩序，我们必须向物理系统中添加能量。软件系统也是如此：架构师必须不断地花费精力来确保良好的结构稳固性，这不会偶然发生。

保持良好的模块化体现了我们对隐式架构特征的定义:事实上，没有项目会要求架构师确保良好的模块化区分和交流，但可持续的代码库需要顺序和一致性。

## 定义

字典将*模块*定义为“一组可用于构建更复杂结构的标准化部件或独立单元中的每一个”。我们使用模块化来描述相关代码的逻辑分组，这些代码可以是面向对象语言中的一组类，也可以是结构化或函数式语言中的一组函数。大多数语言都提供了模块化机制(Java中的包，.net中的名称空间，等等)。开发人员通常使用模块作为将相关代码分组的一种方式。例如，Java中的`com.mycompany.customer`包应该包含与客户相关的内容。

语言现在具有各种各样的打包机制，这使得开发人员很难在它们之间做出选择。例如，在许多现代语言中，开发人员可以在函数/方法、类或包/名称空间中定义行为，每个都具有不同的可见性和作用域规则。其他语言通过添加编程构造(如元对象协议)来为开发人员提供更多的扩展机制，从而使这一问题进一步复杂化。

架构师必须了解开发人员如何打包东西，因为这在架构中具有重要的含义。例如，如果几个包紧密耦合在一起，重用它们中的一个进行相关工作就会变得更加困难。

------
### 类之前的模块化重用

在面向对象语言出现之前的开发人员可能会对为什么普遍存在这么多不同的分离方案感到困惑。很多原因与向后兼容性有关，而不是代码的兼容性，而是开发人员思考问题的方式。1968年3月，Edsger Dijkstra在*ACM通讯*上发表了一封题为“发表有害言论”的信。他贬低了`GOTO`语句在当时编程语言中的普遍使用，这种语句允许在代码中进行非线性切换，使得推理和调试变得困难。

这篇论文帮助我们进入了结构化编程语言的时代，以Pascal和C为例，它鼓励我们对事物如何组合在一起进行更深入的思考。开发人员很快意识到，大多数语言都没有很好的方法将类似的东西逻辑地组合在一起。因此，模块化语言的短暂时代诞生了，比如Modula（Pascal的创造者Niklaus Wirth的下一种语言）和Ada。这些语言具有模块的编程构造，就像我们现在考虑的包或名称空间一样(但没有类)。

模块化编程时代是短暂的。面向对象语言之所以流行，是因为它们提供了封装和重用代码的新方法。尽管如此，语言设计者还是意识到了模块的效用，以包、名称空间等形式保留了它们。语言中存在许多奇怪的兼容性特性来支持这些不同的范例。例如，Java支持模块化(通过使用静态初始化器的包和包级初始化)、面向对象和函数式范式，每种编程风格都有自己的作用域规则和怪癖。

------

对于体系结构的讨论，我们使用模块化作为一个通用术语来表示相关的代码分组:类、函数或任何其他分组。这并不意味着物理上的分离，只是逻辑上的分离;这种区别有时很重要。例如，从方便的角度来看，将大量的类集中在一个整体应用程序中可能是有意义的。然而，当重构体系结构时，松散分区所鼓励的耦合将成为打破整体的障碍。因此，将模块化作为一个概念与特定平台强制或暗示的物理分离分离开来是很有用的。

值得注意的是命名空间的一般概念，它独立于. net平台中的技术实现。开发人员经常需要精确的、完全限定的软件资产名称，以将不同的软件资产(组件、类等)彼此分开。人们每天使用的最明显的例子就是互联网:与IP地址绑定的唯一、全球标识符。大多数语言都有一些模块化机制，可以作为名称空间来组织变量、函数和/或方法。有时模块结构在物理上反映出来。例如，Java要求它的包结构必须反映物理类文件的目录结构。

------

### 没有名称冲突的语言:Java 1.0

Java最初的设计者在处理当时各种编程平台上的名称冲突和冲突方面有丰富的经验。Java的原始设计使用了一种巧妙的方法来避免两个具有相同名称的类之间的歧义。例如，如果您的问题域包括目录订单和安装订单:两者都是命名订单，但内涵(和类)非常不同。Java中的解决方案是创建包名称空间机制，同时要求物理目录结构只与包名匹配。因为文件系统不允许相同的命名文件驻留在相同的目录中，所以它们利用了操作系统的固有特性来避免歧义的可能性。因此，Java中的原始类路径只包含目录，从而避免了名称冲突的可能性。

然而，正如语言设计者发现的那样，强迫每个项目都有一个完全成形的目录结构是很麻烦的，特别是当项目变得更大的时候。此外，构建可重用资产是困难的:框架和库必须被“分解”到目录结构中。在Java的第二个主要发行版(1.2，称为Java 2)中，设计者添加了jar机制，允许存档文件充当类路径上的目录结构。在接下来的十年中，Java开发人员努力使类路径作为目录和JAR文件的组合完全正确。当然，最初的意图被打破了:现在两个JAR文件可能会在类路径上创建冲突的名称，从而导致调试类装入器的许多争论。

------

## 测量模块

考虑到模块化对架构师的重要性，他们需要工具来理解它。幸运的是，研究人员创建了各种与语言无关的度量标准，以帮助架构师理解模块化。我们关注三个关键概念:内聚、耦合和连接。

### 凝聚力

内聚是指模块的各个部分应该包含在同一个模块中的程度。换句话说，它是一种度量各部分之间联系程度的方法。理想情况下，内聚模块是所有部分都应该打包在一起的模块，因为将它们分解为更小的部分需要通过模块之间的调用将这些部分耦合在一起，以获得有用的结果。

​	*试图分割内聚模块只会增加耦合并降低可读性。*

​																——拉里·康斯坦丁

计算机科学家已经定义了一系列的凝聚力衡量标准，下面列出了从最好到最差的标准:

​	*功能的凝聚力*

​		模块的每个部分都是相互关联的，模块包含了所有必需的功能。

​	*连续的凝聚力*

​		两个模块相互作用，其中一个模块输出数据，成为另一个模块的输入。

​	*交往的凝聚力*

​		两个模块构成一个通信链，其中每个模块都对信息进行操作并/或贡献一些输出。例如，向数据库添加一条记录，并根据该信息生成一封电子邮件。

​	*程序上的凝聚力*

​		两个模块必须以特定的顺序执行代码。

​	*颞凝聚力*

​		模块是根据定时依赖关系进行关联的。例如，许多系统有一个看似不相关的列表，必须在系统启动时进行初始化;这些不同的任务在时间上是紧密相连的。

​	*逻辑内聚*

​		模块内的数据在逻辑上相关，但在功能上不相关。例如，考虑一个将信息从文本、序列化对象或流转换过来的模块。操作是相关的，但函数是完全不同的。这种内聚类型的一个常见例子以StringUtils包的形式存在于几乎每个Java项目中:一组操作String但在其他方面不相关的静态方法。

​	*巧合的凝聚力*

​		模块中的元素除了在同一个源文件中之外，没有其他关联;这代表了最消极的凝聚形式。

尽管列出了7个变量，但内聚性是一个不如耦合精确的度量标准。通常，特定模块的内聚程度由特定架构师决定。例如，考虑以下模块定义:

​	*客户维护*

- 添加客户
- 更新客户
- 获取客户
- 通知客户
- 获取客户订单
- 取消客户订单